use anyhow::Result;
use dashmap::DashMap;
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize)]
struct OsvRequest {
    package: OsvPackage,
    version: String,
}

#[derive(Debug, Serialize)]
struct OsvPackage {
    name: String,
    ecosystem: String,
}

#[derive(Debug, Deserialize)]
struct OsvResponse {
    vulns: Option<Vec<DetailedVulnerability>>,
}

#[derive(Debug, Deserialize)]
pub struct DetailedVulnerability {
    pub id: String,
    pub summary: Option<String>,
    pub details: Option<String>,
    pub severity: Option<Vec<Severity>>,
}

#[derive(Debug, Deserialize)]
pub struct Severity {
    #[serde(rename = "type")]
    pub severity_type: String,
    pub score: String,
}

#[derive(Debug, Clone)]
pub struct VulnerabilityReport {
    pub id: String,
    pub summary: String,
    pub score: Option<String>,
}

/// Global cache for vulnerability reports to avoid redundant network calls
static VULN_CACHE: std::sync::LazyLock<DashMap<String, Vec<VulnerabilityReport>>> =
    std::sync::LazyLock::new(DashMap::new);

/// Vulnerability scanner using OSV/CVE database
pub struct VulnerabilityScanner {
    client: reqwest::Client,
}

impl Default for VulnerabilityScanner {
    fn default() -> Self {
        Self::new()
    }
}

impl VulnerabilityScanner {
    #[must_use]
    pub fn new() -> Self {
        Self {
            // 3 second timeout to prevent hanging on slow/unavailable networks
            client: reqwest::Client::builder()
                .timeout(std::time::Duration::from_secs(3))
                .connect_timeout(std::time::Duration::from_secs(2))
                .build()
                .unwrap_or_else(|_| reqwest::Client::new()),
        }
    }

    /// Scan a package against the OSV database
    pub async fn scan_package(
        &self,
        name: &str,
        version: &str,
    ) -> Result<Vec<VulnerabilityReport>> {
        let cache_key = format!("{name}-{version}");

        // 1. Check cache first (Sub-microsecond)
        if let Some(cached) = VULN_CACHE.get(&cache_key) {
            return Ok(cached.clone());
        }

        let request = OsvRequest {
            package: OsvPackage {
                name: name.to_string(),
                ecosystem: "Arch Linux".to_string(),
            },
            version: version.to_string(),
        };

        // Try OSV API with timeout, gracefully handle failures
        let response: OsvResponse = if let Ok(resp) = self
            .client
            .post("https://api.osv.dev/v1/query")
            .json(&request)
            .send()
            .await
        {
            if let Ok(json) = resp.json().await {
                json
            } else {
                // Cache empty result to avoid repeated slow requests
                VULN_CACHE.insert(cache_key, vec![]);
                return Ok(vec![]);
            }
        } else {
            // Network timeout/error - cache empty result and continue
            VULN_CACHE.insert(cache_key, vec![]);
            return Ok(vec![]);
        };

        let mut reports = Vec::new();
        // ... (rest of logic remains same)
        if let Some(vulns) = response.vulns {
            for vuln in vulns {
                let score = vuln
                    .severity
                    .as_ref()
                    .and_then(|s| s.first())
                    .map(|s| s.score.clone());

                reports.push(VulnerabilityReport {
                    id: vuln.id,
                    summary: vuln
                        .summary
                        .unwrap_or_else(|| "No summary provided".to_string()),
                    score,
                });
            }
        }

        // 2. Store in cache
        VULN_CACHE.insert(cache_key, reports.clone());

        Ok(reports)
    }
}
