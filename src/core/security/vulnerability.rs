use crate::package_managers::types::Version;
use anyhow::Result;
use dashmap::DashMap;
use serde::{Deserialize, Serialize};

use crate::core::http::shared_client;

#[derive(Debug, Serialize)]
struct OsvRequest {
    package: OsvPackage,
    version: String,
}

#[derive(Debug, Serialize)]
struct OsvPackage {
    name: String,
    ecosystem: String,
}

#[derive(Debug, Deserialize)]
struct OsvResponse {
    vulns: Option<Vec<DetailedVulnerability>>,
}

#[derive(Debug, Deserialize)]
pub struct DetailedVulnerability {
    pub id: String,
    pub summary: Option<String>,
    pub details: Option<String>,
    pub severity: Option<Vec<Severity>>,
}

#[derive(Debug, Deserialize)]
pub struct Severity {
    #[serde(rename = "type")]
    pub severity_type: String,
    pub score: String,
}

#[derive(Debug, Clone)]
pub struct VulnerabilityReport {
    pub id: String,
    pub summary: String,
    pub score: Option<String>,
}

/// Global cache for vulnerability reports to avoid redundant network calls
static VULN_CACHE: std::sync::LazyLock<DashMap<String, Vec<VulnerabilityReport>>> =
    std::sync::LazyLock::new(DashMap::new);

/// Vulnerability scanner using OSV/CVE database
pub struct VulnerabilityScanner {
    client: reqwest::Client,
}

impl Default for VulnerabilityScanner {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct AlsaIssue {
    pub name: String,
    pub packages: Vec<String>,
    pub status: String,
    pub severity: String,
    pub affected: String,
    pub fixed: Option<String>,
    pub issues: Vec<String>,
}

impl VulnerabilityScanner {
    pub fn new() -> Self {
        Self {
            client: shared_client().clone(),
        }
    }

    /// Fetch all current Arch Linux security issues
    pub async fn fetch_alsa_issues(&self) -> Result<Vec<AlsaIssue>> {
        let resp = self
            .client
            .get("https://security.archlinux.org/issues/all.json")
            .send()
            .await?;

        let issues: Vec<AlsaIssue> = resp.json().await?;

        // Filter for only vulnerable statuses
        let vulnerable: Vec<AlsaIssue> = issues
            .into_iter()
            .filter(|i| i.status.to_lowercase().contains("vulnerable"))
            .collect();

        Ok(vulnerable)
    }

    /// Perform a full system scan using ALSA data
    pub async fn scan_system(&self) -> Result<usize> {
        let issues = self.fetch_alsa_issues().await?;

        // Get all installed packages
        #[cfg(feature = "arch")]
        let installed = crate::package_managers::list_installed_fast()
            .map_err(|e| anyhow::anyhow!("Failed to list packages: {e}"))?;
        #[cfg(all(feature = "debian", not(feature = "arch")))]
        let installed = crate::package_managers::apt_list_installed_fast()
            .map_err(|e| anyhow::anyhow!("Failed to list packages: {e}"))?;
        #[cfg(not(any(feature = "arch", feature = "debian")))]
        let installed: Vec<crate::package_managers::types::LocalPackage> = Vec::new();

        let mut vuln_count = 0;

        for issue in &issues {
            for pkg_name in &issue.packages {
                if let Some(local_pkg) = installed.iter().find(|p| p.name == *pkg_name) {
                    // Simple version check: if it matches the 'affected' exact version
                    // In a perfect world, we'd use alpm_pkg_vercmp but this is a good first pass
                    #[allow(clippy::cmp_owned, clippy::implicit_clone)]
                    if local_pkg.version.to_string() == issue.affected {
                        vuln_count += 1;
                        break; // Count this issue once
                    }
                }
            }
        }

        Ok(vuln_count)
    }

    /// Scan a package against the OSV database
    pub async fn scan_package(
        &self,
        name: &str,
        version: &Version,
    ) -> Result<Vec<VulnerabilityReport>> {
        #[allow(clippy::implicit_clone)]
        let version_str = version.to_string();
        let cache_key = format!("{name}-{version_str}");
        if let Some(cached) = VULN_CACHE.get(&cache_key) {
            return Ok(cached.clone());
        }

        let request = OsvRequest {
            package: OsvPackage {
                name: name.to_string(),
                ecosystem: "Arch Linux".to_string(),
            },
            #[allow(clippy::implicit_clone)]
            version: version.to_string(),
        };

        let response: OsvResponse = if let Ok(resp) = self
            .client
            .post("https://api.osv.dev/v1/query")
            .json(&request)
            .send()
            .await
        {
            resp.json().await.unwrap_or(OsvResponse { vulns: None })
        } else {
            OsvResponse { vulns: None }
        };

        let mut reports = Vec::new();
        if let Some(vulns) = response.vulns {
            for vuln in vulns {
                let score = vuln
                    .severity
                    .as_ref()
                    .and_then(|s| s.first())
                    .map(|s| s.score.clone());

                reports.push(VulnerabilityReport {
                    id: vuln.id,
                    summary: vuln
                        .summary
                        .unwrap_or_else(|| "No summary provided".to_string()),
                    score,
                });
            }
        }

        VULN_CACHE.insert(cache_key, reports.clone());
        Ok(reports)
    }
}
