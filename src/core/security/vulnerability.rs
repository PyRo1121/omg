use crate::package_managers::types::Version;
use anyhow::Result;
use moka::sync::Cache;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use std::time::Duration;

use crate::core::http::shared_client;

#[derive(Debug, Serialize)]
struct OsvRequest {
    package: OsvPackage,
    version: String,
}

#[derive(Debug, Serialize)]
struct OsvPackage {
    name: String,
    ecosystem: String,
}

#[derive(Debug, Deserialize)]
struct OsvResponse {
    vulns: Option<Vec<DetailedVulnerability>>,
}

#[derive(Debug, Deserialize)]
pub struct DetailedVulnerability {
    pub id: String,
    pub summary: Option<String>,
    pub details: Option<String>,
    pub severity: Option<Vec<Severity>>,
}

#[derive(Debug, Deserialize)]
pub struct Severity {
    #[serde(rename = "type")]
    pub severity_type: String,
    pub score: String,
}

#[derive(Debug, Clone)]
pub struct VulnerabilityReport {
    pub id: String,
    pub summary: String,
    pub score: Option<String>,
}

/// Global cache for vulnerability reports to avoid redundant network calls
/// LRU cache with 10-minute TTL and 10,000 entry limit to prevent unbounded growth
static VULN_CACHE: std::sync::LazyLock<Cache<String, Arc<Vec<VulnerabilityReport>>>> =
    std::sync::LazyLock::new(|| {
        Cache::builder()
            .max_capacity(10_000)
            .time_to_live(Duration::from_secs(10 * 60)) // 10 minutes
            .build()
    });

/// Vulnerability scanner using OSV/CVE database
pub struct VulnerabilityScanner {
    client: reqwest::Client,
}

impl Default for VulnerabilityScanner {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct AlsaIssue {
    pub name: String,
    pub packages: Vec<String>,
    pub status: String,
    pub severity: String,
    pub affected: String,
    pub fixed: Option<String>,
    pub issues: Vec<String>,
}

impl VulnerabilityScanner {
    pub fn new() -> Self {
        Self {
            client: shared_client().clone(),
        }
    }

    /// Fetch all current Arch Linux security issues
    pub async fn fetch_alsa_issues(&self) -> Result<Vec<AlsaIssue>> {
        let resp = self
            .client
            .get("https://security.archlinux.org/issues/all.json")
            .send()
            .await?;

        let issues: Vec<AlsaIssue> = resp.json().await?;

        // Filter for only vulnerable statuses
        let vulnerable: Vec<AlsaIssue> = issues
            .into_iter()
            .filter(|i| i.status.to_lowercase().contains("vulnerable"))
            .collect();

        Ok(vulnerable)
    }

    /// Perform a full system scan using ALSA data
    pub async fn scan_system(&self) -> Result<usize> {
        let issues = self.fetch_alsa_issues().await?;

        // Get all installed packages
        #[cfg(feature = "arch")]
        let installed = crate::package_managers::list_installed_fast()
            .map_err(|e| anyhow::anyhow!("Failed to list packages: {e}"))?;
        #[cfg(all(feature = "debian", not(feature = "arch")))]
        let installed = crate::package_managers::apt_list_installed_fast()
            .map_err(|e| anyhow::anyhow!("Failed to list packages: {e}"))?;
        #[cfg(not(any(feature = "arch", feature = "debian")))]
        let installed: Vec<crate::package_managers::types::LocalPackage> = Vec::new();

        let mut vuln_count = 0;

        for issue in &issues {
            for pkg_name in &issue.packages {
                if let Some(local_pkg) = installed.iter().find(|p| p.name == *pkg_name) {
                    // Simple version check: if it matches the 'affected' exact version
                    // In a perfect world, we'd use alpm_pkg_vercmp but this is a good first pass
                    #[allow(clippy::cmp_owned, clippy::implicit_clone)]
                    // Version is feature-gated type alias; comparison and conversion required
                    if local_pkg.version.to_string() == issue.affected {
                        vuln_count += 1;
                        break; // Count this issue once
                    }
                }
            }
        }

        Ok(vuln_count)
    }

    /// Scan a package against the OSV database
    pub async fn scan_package(
        &self,
        name: &str,
        version: &Version,
    ) -> Result<Vec<VulnerabilityReport>> {
        #[allow(clippy::implicit_clone)]
        // Version is feature-gated type alias; .to_string() is the required conversion
        let version_str = version.to_string();
        let cache_key = format!("{name}-{version_str}");
        if let Some(cached) = VULN_CACHE.get(&cache_key) {
            return Ok((*cached).clone());
        }

        let request = OsvRequest {
            package: OsvPackage {
                name: name.to_string(),
                ecosystem: "Arch Linux".to_string(),
            },
            #[allow(clippy::implicit_clone)] // Version is feature-gated type alias; .to_string() is the required conversion
            version: version.to_string(),
        };

        let response: OsvResponse = if let Ok(resp) = self
            .client
            .post("https://api.osv.dev/v1/query")
            .json(&request)
            .send()
            .await
        {
            resp.json().await.unwrap_or(OsvResponse { vulns: None })
        } else {
            OsvResponse { vulns: None }
        };

        let mut reports = Vec::new();
        if let Some(vulns) = response.vulns {
            for vuln in vulns {
                let score = vuln
                    .severity
                    .as_ref()
                    .and_then(|s| s.first())
                    .map(|s| s.score.clone());

                reports.push(VulnerabilityReport {
                    id: vuln.id,
                    summary: vuln
                        .summary
                        .unwrap_or_else(|| "No summary provided".to_string()),
                    score,
                });
            }
        }

        VULN_CACHE.insert(cache_key, Arc::new(reports.clone()));
        Ok(reports)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vulnerability_scanner_new() {
        let scanner = VulnerabilityScanner::new();
        // Should construct successfully
        assert!(std::ptr::addr_of!(scanner.client) as usize > 0);
    }

    #[test]
    fn test_vulnerability_scanner_default() {
        let scanner = VulnerabilityScanner::default();
        // Default should be equivalent to new()
        assert!(std::ptr::addr_of!(scanner.client) as usize > 0);
    }

    #[test]
    fn test_vulnerability_report_creation() {
        let report = VulnerabilityReport {
            id: "CVE-2024-1234".to_string(),
            summary: "Test vulnerability".to_string(),
            score: Some("7.5".to_string()),
        };

        assert_eq!(report.id, "CVE-2024-1234");
        assert_eq!(report.summary, "Test vulnerability");
        assert_eq!(report.score, Some("7.5".to_string()));
    }

    #[test]
    fn test_alsa_issue_deserialization() {
        let json = r#"{
            "name": "ASA-202401-1",
            "packages": ["package1", "package2"],
            "status": "Vulnerable",
            "severity": "High",
            "affected": "1.0.0",
            "fixed": "1.0.1",
            "issues": ["CVE-2024-1234"]
        }"#;

        let issue: Result<AlsaIssue, _> = serde_json::from_str(json);
        assert!(issue.is_ok());

        let issue = issue.unwrap();
        assert_eq!(issue.name, "ASA-202401-1");
        assert_eq!(issue.packages, vec!["package1", "package2"]);
        assert_eq!(issue.status, "Vulnerable");
        assert_eq!(issue.severity, "High");
        assert_eq!(issue.affected, "1.0.0");
        assert_eq!(issue.fixed, Some("1.0.1".to_string()));
        assert_eq!(issue.issues, vec!["CVE-2024-1234"]);
    }

    #[test]
    fn test_alsa_issue_without_fixed_version() {
        let json = r#"{
            "name": "ASA-202401-2",
            "packages": ["package3"],
            "status": "Vulnerable",
            "severity": "Critical",
            "affected": "2.0.0",
            "fixed": null,
            "issues": ["CVE-2024-5678"]
        }"#;

        let issue: Result<AlsaIssue, _> = serde_json::from_str(json);
        assert!(issue.is_ok());

        let issue = issue.unwrap();
        assert_eq!(issue.name, "ASA-202401-2");
        assert_eq!(issue.fixed, None);
    }

    #[test]
    fn test_osv_request_serialization() {
        let request = OsvRequest {
            package: OsvPackage {
                name: "test-package".to_string(),
                ecosystem: "Arch Linux".to_string(),
            },
            version: "1.2.3".to_string(),
        };

        let json = serde_json::to_string(&request).unwrap();
        assert!(json.contains("test-package"));
        assert!(json.contains("Arch Linux"));
        assert!(json.contains("1.2.3"));
    }
}
